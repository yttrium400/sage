"""
File operations for code editing
"""

import os
import re
from typing import Optional, List, Tuple
from pathlib import Path
from rich.console import Console
from rich.syntax import Syntax
from rich.panel import Panel
from rich.prompt import Confirm
import difflib

console = Console()


def read_file(file_path: str) -> Optional[str]:
    """Read file contents safely"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        console.print(f"[red]Error: File not found: {file_path}[/red]")
        return None
    except Exception as e:
        console.print(f"[red]Error reading file: {e}[/red]")
        return None


def write_file(file_path: str, content: str, confirm: bool = True) -> bool:
    """Write content to file with confirmation"""

    # Check if file exists
    exists = os.path.exists(file_path)

    if exists:
        action = "overwrite"
        old_content = read_file(file_path)
    else:
        action = "create"
        old_content = None

    # Show what will happen
    console.print(f"\n[yellow]About to {action}: {file_path}[/yellow]")

    if old_content and confirm:
        # Show diff
        show_diff(old_content, content, file_path)
    else:
        # Show new content
        console.print("\n[dim]New content:[/dim]")
        syntax = Syntax(content, "python", theme="monokai", line_numbers=True)
        console.print(Panel(syntax, title=f"[cyan]{file_path}[/cyan]", border_style="cyan"))

    # Ask for confirmation
    if confirm:
        confirmed = Confirm.ask(f"\n{action.capitalize()} this file?", default=False)
        if not confirmed:
            console.print("[dim]Operation cancelled.[/dim]")
            return False

    # Write file
    try:
        # Create directory if needed
        os.makedirs(os.path.dirname(file_path) or '.', exist_ok=True)

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)

        console.print(f"[green]✓ Successfully {action}d: {file_path}[/green]")
        return True

    except Exception as e:
        console.print(f"[red]Error writing file: {e}[/red]")
        return False


def show_diff(old_content: str, new_content: str, file_path: str):
    """Show diff between old and new content"""

    old_lines = old_content.splitlines(keepends=True)
    new_lines = new_content.splitlines(keepends=True)

    diff = difflib.unified_diff(
        old_lines,
        new_lines,
        fromfile=f"a/{file_path}",
        tofile=f"b/{file_path}",
        lineterm=''
    )

    diff_text = ''.join(diff)

    if diff_text:
        console.print("\n[dim]Changes:[/dim]")
        syntax = Syntax(diff_text, "diff", theme="monokai", line_numbers=False)
        console.print(Panel(syntax, title="[yellow]Diff[/yellow]", border_style="yellow"))
    else:
        console.print("\n[dim]No changes detected.[/dim]")


def append_to_file(file_path: str, content: str, confirm: bool = True) -> bool:
    """Append content to existing file"""

    if not os.path.exists(file_path):
        console.print(f"[red]Error: File does not exist: {file_path}[/red]")
        return False

    old_content = read_file(file_path)
    if old_content is None:
        return False

    new_content = old_content + content

    console.print(f"\n[yellow]About to append to: {file_path}[/yellow]")
    console.print("\n[dim]Content to append:[/dim]")
    syntax = Syntax(content, "python", theme="monokai", line_numbers=False)
    console.print(Panel(syntax, border_style="cyan"))

    if confirm:
        confirmed = Confirm.ask("\nAppend this content?", default=False)
        if not confirmed:
            console.print("[dim]Operation cancelled.[/dim]")
            return False

    return write_file(file_path, new_content, confirm=False)


def list_files(directory: str, pattern: str = "*.py") -> List[str]:
    """List Python files in directory"""
    try:
        path = Path(directory)
        files = list(path.rglob(pattern))
        return [str(f.relative_to(directory)) for f in files if f.is_file()]
    except Exception as e:
        console.print(f"[red]Error listing files: {e}[/red]")
        return []


def clean_code_content(code: str) -> str:
    """Clean up code content generated by model

    Removes numbered lines, function headers, etc.
    """
    lines = code.split('\n')
    cleaned_lines = []

    for line in lines:
        # Skip lines that look like:
        # "   1 # Function: something()"
        # "   2 def something():"
        # Check if line starts with spaces + numbers + special char
        stripped = line.lstrip()
        if stripped and stripped[0].isdigit():
            # Extract just the code part after the line number
            # Pattern: "   123 code here" or "   123→code here"
            parts = re.split(r'^\s*\d+\s*[→\s]', line, maxsplit=1)
            if len(parts) > 1:
                cleaned_lines.append(parts[1])
            continue

        # Skip lines that are just function/class headers like "# Function: foo()"
        if re.match(r'^\s*#\s*(?:Function|Class):\s*\w+', line):
            continue

        cleaned_lines.append(line)

    return '\n'.join(cleaned_lines)


def extract_code_blocks(text: str) -> List[Tuple[Optional[str], str]]:
    """Extract code blocks from markdown text

    Returns list of (filename, code) tuples
    """
    import re

    # Pattern to match code blocks with optional filename
    # Example: ```python:filename.py  or just ```python or just ```
    # Don't match placeholder examples like "python:path/to" or "python:ACTUAL_FILENAME"
    pattern = r'```python:(?!path/|ACTUAL_FILENAME|filename)([^\n]+)\n(.*?)```|```python\n(.*?)```|```\n(.*?)```'

    matches = re.findall(pattern, text, re.DOTALL)

    results = []
    for match in matches:
        # match is (filename_with_colon, code_with_colon, code_without_lang, code_bare)
        if match[0]:  # ```python:filename.py
            filename = match[0].strip()
            code = match[1].strip()
            code = clean_code_content(code)
        elif match[2]:  # ```python (no filename)
            filename = None
            code = match[2].strip()
            code = clean_code_content(code)
        else:  # ``` (bare)
            filename = None
            code = match[3].strip()
            code = clean_code_content(code)

        if code:  # Only include non-empty code blocks
            results.append((filename, code))

    return results


def propose_file_changes(response: str, context_dir: str, inferred_files: List[str] = None) -> List[Tuple[str, str]]:
    """Parse assistant response for proposed file changes

    Returns list of (filepath, content) tuples

    Args:
        response: The model's response text
        context_dir: Directory for context
        inferred_files: List of files inferred from the query (for smart matching)
    """
    code_blocks = extract_code_blocks(response)

    proposals = []
    unnamed_blocks = []

    for filename, code in code_blocks:
        if filename:
            # Make path relative to context directory
            filepath = os.path.join(context_dir, filename)
            proposals.append((filepath, code))
        else:
            # Code block without filename
            unnamed_blocks.append(code)

    # Smart matching: if we have unnamed blocks and inferred files, match them
    if unnamed_blocks and inferred_files:
        # Match unnamed blocks to inferred files in order
        for code, target_file in zip(unnamed_blocks, inferred_files):
            filepath = os.path.join(context_dir, target_file)
            proposals.append((filepath, code))

    return proposals
